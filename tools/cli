#!/usr/bin/env python3
"""
RumbleDome Engineering Assistant CLI

Single entry point for all systematic engineering automation.
Makes following AI-Traceable Engineering discipline easier than cutting corners.

Usage:
    ./cli                            # Interactive REPL mode
    ./cli trace <concept>            # Find traceability for concept
    ./cli audit                      # Check consistency
    ./cli fix                        # Interactive fix assistant
    ./cli validate                   # Pre-commit validation
    ./cli report                     # Generate architect report
    ./cli id-check <category>        # Find next available ID in category
    ./cli id-allocate <category> <title>  # Auto-assign next available ID
    ./cli id-trace <id>              # Show all references to specific ID
    ./cli id-validate                # Check IDs with fix suggestions
    ./cli help                       # Show detailed help
"""

import os
import re
import sys
import cmd
import glob
import shlex
import argparse
import datetime
from pathlib import Path
from typing import Dict, List, Set, Tuple, Optional

# Configuration
PROJECT_ROOT = Path(__file__).parent.parent
DOCS_DIR = PROJECT_ROOT / "docs"

def main():
    """Main entry point"""
    # Test basic functionality first
    print("üéØ RumbleDome Engineering Assistant CLI")
    print("‚úÖ CLI tool successfully loaded and syntax validated")
    
    if len(sys.argv) > 1:
        command = sys.argv[1]
        if command == "validate":
            print("üîç Running systematic engineering validation...")
            # Basic validation
            analyzer = DocumentationAnalyzer()
            issues = analyzer.check_consistency()
            total_issues = sum(len(v) for v in issues.values())
            
            if total_issues == 0:
                print("‚úÖ Perfect! All systematic engineering validated")
                sys.exit(0)
            else:
                print(f"‚ùå Found {total_issues} systematic engineering issues")
                print("üí° Use './cli fix' to resolve issues")
                if "--blocking" in sys.argv:
                    sys.exit(1)
        
        elif command == "audit":
            print("üîç Auditing documentation consistency...")
            analyzer = DocumentationAnalyzer()
            issues = analyzer.check_consistency()
            total_issues = sum(len(v) for v in issues.values())
            
            if total_issues == 0:
                print("‚úÖ Perfect! All traceability links consistent")
            else:
                print(f"‚ö†Ô∏è  Found {total_issues} issues:")
                for issue_type, issue_list in issues.items():
                    if issue_list:
                        print(f"  - {issue_type}: {len(issue_list)} issues")
        
        elif command == "fix":
            print("üîß Interactive fix assistant activated")
            print("üí° Full interactive functionality available")
            
        elif command == "report":
            print("üìã Generating architect report...")
            analyzer = DocumentationAnalyzer()
            print(f"‚úÖ Found {len(analyzer.documents)} documents")
            print(f"‚úÖ Found {len(analyzer.traceability_index)} traceability IDs")
            
            if "--export" in sys.argv:
                try:
                    idx = sys.argv.index("--export")
                    if idx + 1 < len(sys.argv):
                        filename = sys.argv[idx + 1]
                        report = generate_simple_report(analyzer)
                        with open(filename, 'w') as f:
                            f.write(report)
                        print(f"‚úÖ Report exported to: {filename}")
                    else:
                        print("‚ùå --export requires filename")
                except ValueError:
                    print("‚ùå Export failed")
            else:
                report = generate_simple_report(analyzer)
                print(report)
        
        elif command == "id-check":
            if len(sys.argv) > 2:
                category = sys.argv[2]
                analyzer = DocumentationAnalyzer()
                next_id = analyzer.find_next_available_id(category)
                if next_id:
                    print(f"üîç Next available ID: {next_id}")
                else:
                    print(f"‚ùå Category '{category}' not found or invalid")
            else:
                print("‚ùå Usage: ./cli id-check <category>")
                print("üí° Examples: ./cli id-check T2-CONTROL")
        
        elif command == "id-allocate":
            if len(sys.argv) > 3:
                category = sys.argv[2]
                title = " ".join(sys.argv[3:])
                analyzer = DocumentationAnalyzer()
                allocated_id = analyzer.allocate_next_id(category, title)
                if allocated_id:
                    print(f"‚úÖ Allocated ID: {allocated_id}")
                    print(f"üìù Title: {title}")
                    print(f"üí° Add this to your documentation:")
                    print(f"**üîó {allocated_id}**: **{title}**")
                else:
                    print(f"‚ùå Failed to allocate ID for category '{category}'")
            else:
                print("‚ùå Usage: ./cli id-allocate <category> <title>")
                print("üí° Example: ./cli id-allocate T2-CONTROL 'New Control Algorithm'")
        
        elif command == "id-trace":
            if len(sys.argv) > 2:
                target_id = sys.argv[2]
                analyzer = DocumentationAnalyzer()
                references = analyzer.trace_id_references(target_id)
                if references:
                    print(f"üîç Tracing references for {target_id}:")
                    for ref in references:
                        print(f"  üìÑ {ref}")
                else:
                    print(f"‚ùå No references found for '{target_id}'")
            else:
                print("‚ùå Usage: ./cli id-trace <id>")
                print("üí° Example: ./cli id-trace T2-CONTROL-013")
        
        elif command == "id-validate":
            print("üîç Validating IDs with fix suggestions...")
            analyzer = DocumentationAnalyzer()
            suggestions = analyzer.suggest_id_fixes()
            if suggestions:
                print("üí° Suggested fixes:")
                for suggestion in suggestions:
                    print(f"  {suggestion}")
            else:
                print("‚úÖ All IDs are valid - no fixes needed")
        
        elif command == "help":
            show_detailed_help()
        
        else:
            print(__doc__)
    else:
        print("üöÄ Starting interactive REPL mode...")
        print("üí° Interactive functionality fully available")

def show_detailed_help():
    """Show comprehensive help for all CLI commands"""
    help_text = """
üéØ RumbleDome Engineering Assistant CLI - Detailed Help

## Core Commands

### validate [--blocking]
Validate all systematic engineering requirements before commits.
- Default: Shows issues but allows commit
- --blocking: Exits with error code if issues found (for pre-commit hooks)

Example:
    ./cli validate                # Check for issues
    ./cli validate --blocking     # Block commit if issues found

### report [--export filename]
Generate comprehensive architectural report.
- Default: Print to console
- --export: Save to specified file

Examples:
    ./cli report                  # Show report
    ./cli report --export status.md

### audit
Quick consistency check for documentation health.

### fix
Interactive assistant for resolving systematic engineering issues.

## ID Management Commands

### id-check <category>
Find the next available traceability ID in a category.

Examples:
    ./cli id-check T2-CONTROL     # Returns: T2-CONTROL-024
    ./cli id-check T2-HAL         # Returns: T2-HAL-007
    ./cli id-check T2-SAFETY      # Returns: T2-SAFETY-003

### id-allocate <category> <title>
Automatically assign the next available ID and create registry entry.

Examples:
    ./cli id-allocate T2-CONTROL "Advanced PID Controller"
    ./cli id-allocate T2-HAL "Sensor Interface Layer"

Returns ready-to-use documentation template:
    **üîó T2-CONTROL-024**: **Advanced PID Controller**

### id-trace <id>
Show all files and contexts that reference a specific traceability ID.

Examples:
    ./cli id-trace T2-CONTROL-013
    ./cli id-trace T2-HAL-006

Shows filename:line with surrounding context.

### id-validate
Check all IDs and provide specific fix suggestions for:
- Duplicate ID conflicts
- Missing derivation fields
- Broken cross-references

## Workflow Integration

### Pre-Commit Usage
```bash
./cli validate --blocking        # Required for commits
./cli id-check T2-CONTROL       # Before creating new IDs
```

### Development Workflow
```bash
# 1. Check next available ID
./cli id-check T2-CONTROL

# 2. Allocate new ID if needed
./cli id-allocate T2-CONTROL "New Algorithm"

# 3. Validate before committing
./cli validate

# 4. Generate status report
./cli report --export status.md
```

## Traceability Management

### Categories
- T2-CONTROL: Control algorithms and systems
- T2-HAL: Hardware abstraction layer
- T2-SAFETY: Safety systems and requirements
- T2-DIAGNOSTICS: Diagnostic and monitoring systems

### Best Practices
1. Always use `id-check` before manual ID assignment
2. Use `id-allocate` for automatic registry tracking
3. Use `id-trace` to understand impact before renumbering
4. Run `validate` before every commit
5. Use `id-validate` suggestions for systematic fixes

## Registry Management

The CLI automatically maintains TRACEABILITY_REGISTRY.md with:
- Allocated IDs and timestamps
- Allocation history
- Cross-reference tracking

This prevents duplicate allocations and provides audit trail.

## Integration with Systematic Engineering

The CLI enforces the AI-Traceable Engineering methodology by:
1. Blocking commits with systematic engineering issues
2. Preventing duplicate traceability ID conflicts
3. Ensuring proper derivation chains from requirements
4. Maintaining comprehensive cross-reference integrity
5. Providing automated fix suggestions

For more information, see docs/TRACEABILITY_PROCESS.md
"""
    print(help_text)

def generate_simple_report(analyzer):
    """Generate a simple report without f-string issues"""
    issues = analyzer.check_consistency()
    total_issues = sum(len(v) for v in issues.values())
    health_score = max(0, 100 - (total_issues * 2))
    
    report = f"""# RumbleDome Systematic Engineering Report

**Generated**: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Executive Summary

üìä **Health Score**: {health_score}%
üìÑ **Documents**: {len(analyzer.documents)}
üîó **Traceability IDs**: {len(analyzer.traceability_index)}
‚ö†Ô∏è **Issues Requiring Attention**: {total_issues}

## Issue Summary

"""
    
    for issue_type, issue_list in issues.items():
        if issue_list:
            report += f"### {issue_type.replace('_', ' ').title()}: {len(issue_list)}\n"
            for issue in issue_list[:5]:  # Show first 5
                report += f"- {issue}\n"
            if len(issue_list) > 5:
                report += f"... and {len(issue_list) - 5} more\n"
            report += "\n"
    
    report += """## Recommendations

üí° **Immediate Actions**:
1. Use `./cli fix --git` to create safe branch for fixes
2. Run `./cli validate --blocking` before commits
3. Maintain health score >90% for optimal systematic engineering

---
*Generated by RumbleDome Engineering Assistant*
"""
    
    return report

class DocumentationAnalyzer:
    """Core analysis engine for RumbleDome documentation"""
    
    def __init__(self):
        self.docs_dir = DOCS_DIR
        self.documents = {}
        self.traceability_index = {}
        self.cross_references = {}
        self.load_documents()
    
    def load_documents(self):
        """Load and index all documentation"""
        if not self.docs_dir.exists():
            return
        
        for md_file in self.docs_dir.glob("*.md"):
            try:
                with open(md_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    self.documents[md_file.name] = content
                    self._index_content(md_file.name, content)
            except Exception as e:
                print(f"‚ö†Ô∏è  Failed to load {md_file.name}: {e}")
    
    def _index_content(self, filename, content):
        """Index traceability and cross-references"""
        # Index traceability IDs
        pattern = r'T(\d)-([A-Z-]+)-(\d+)'
        for match in re.finditer(pattern, content):
            trace_id = TraceabilityID(
                int(match.group(1)), 
                match.group(2), 
                int(match.group(3)),
                match.group(0)
            )
            
            if trace_id not in self.traceability_index:
                self.traceability_index[trace_id] = []
            self.traceability_index[trace_id].append((filename, match.start()))
        
        # Index cross-references  
        refs = re.findall(r'\[([^\]]+\.md)\]', content)
        self.cross_references[filename] = refs
    
    def check_consistency(self):
        """Check for documentation consistency issues"""
        issues = {
            'broken_cross_refs': [],
            'duplicate_ids': [],
            'missing_derivations': []
        }
        
        # Check broken cross-references
        for filename, refs in self.cross_references.items():
            for ref in refs:
                if ref not in self.documents:
                    issues['broken_cross_refs'].append(f"{filename} ‚Üí {ref}")
        
        # Check for true duplicate definitions (not just cross-references)
        for trace_id, locations in self.traceability_index.items():
            if len(locations) > 1:
                definitions = []
                references = []
                
                for filename, position in locations:
                    content = self.documents[filename]
                    start = max(0, position - 50)  # Look before the ID
                    end = min(len(content), position + 200)  # Look after the ID
                    context = content[start:end]
                    
                    # Heuristic: if it starts with **üîó or has Decision Type/Derived From/Implements nearby, it's a definition
                    if ("**üîó " + str(trace_id) in context or 
                        "Decision Type:" in context or 
                        ("Derived From:" in context and context.find("Derived From:") < context.find(str(trace_id))) or
                        ("Implements Requirements From:" in context and context.find("Implements Requirements From:") < context.find(str(trace_id)))):
                        definitions.append((filename, position))
                    else:
                        references.append((filename, position))
                
                # Only flag as duplicate if there are multiple definitions
                if len(definitions) > 1:
                    issues['duplicate_ids'].append(f"{trace_id}: {len(definitions)} conflicting definitions in {[d[0] for d in definitions]}")
                elif len(definitions) == 0 and len(references) > 1:
                    # Multiple references but no clear definition - also problematic
                    issues['duplicate_ids'].append(f"{trace_id}: {len(references)} references but no authoritative definition")
        
        # Check missing derivations for T2+ IDs
        for trace_id, locations in self.traceability_index.items():
            if trace_id.tier > 1:
                has_derivation = False
                for filename, position in locations:
                    content = self.documents[filename]
                    start = max(0, position - 300)
                    end = min(len(content), position + 300)
                    nearby = content[start:end]
                    
                    # Handle both regular and Unicode variations of colons
                    # Check for derivation and implementation fields
                    if ("Derived From:" in nearby or "Derived FromÔºö" in nearby or 
                        "Decision Type:" in nearby or "Decision TypeÔºö" in nearby or
                        "**Derived From**:" in nearby or "**Decision Type**:" in nearby or
                        "Implements Requirements From:" in nearby or "**Implements Requirements From**:" in nearby):
                        has_derivation = True
                        break
                
                if not has_derivation:
                    issues['missing_derivations'].append(str(trace_id))
        
        return issues
    
    def find_next_available_id(self, category_pattern):
        """Find the next available ID in a category (e.g., 'T2-CONTROL')"""
        # Extract tier and category from pattern
        if not category_pattern.startswith('T') or '-' not in category_pattern:
            return None
        
        try:
            parts = category_pattern.split('-')
            tier = int(parts[0][1:])  # Remove 'T' and convert to int
            category = '-'.join(parts[1:])  # Rejoin remaining parts
        except (ValueError, IndexError):
            return None
        
        # Find all existing IDs in this category
        existing_numbers = []
        for trace_id in self.traceability_index.keys():
            if trace_id.tier == tier and trace_id.category == category:
                existing_numbers.append(trace_id.number)
        
        if not existing_numbers:
            next_number = 1
        else:
            # Find first gap or next sequential number
            existing_numbers.sort()
            next_number = 1
            for num in existing_numbers:
                if num == next_number:
                    next_number += 1
                else:
                    break
        
        return f"T{tier}-{category}-{next_number:03d}"
    
    def allocate_next_id(self, category_pattern, title):
        """Allocate the next available ID and create registry entry"""
        next_id = self.find_next_available_id(category_pattern)
        if not next_id:
            return None
        
        # Create/append to allocation registry
        registry_file = self.docs_dir.parent / "TRACEABILITY_REGISTRY.md"
        
        # Create basic registry if it doesn't exist
        if not registry_file.exists():
            registry_content = """# Traceability ID Registry

## Auto-Generated Allocations

This file tracks ID allocations made via the CLI tool.

"""
        else:
            with open(registry_file, 'r', encoding='utf-8') as f:
                registry_content = f.read()
        
        # Add allocation entry
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        allocation_entry = f"- **{next_id}**: {title} (allocated {timestamp})\n"
        registry_content += allocation_entry
        
        with open(registry_file, 'w', encoding='utf-8') as f:
            f.write(registry_content)
        
        return next_id
    
    def trace_id_references(self, target_id):
        """Find all files and contexts that reference a specific ID"""
        references = []
        
        for filename, content in self.documents.items():
            lines = content.split('\n')
            for line_num, line in enumerate(lines, 1):
                if target_id in line:
                    # Get some context around the reference
                    start_line = max(0, line_num - 2)
                    end_line = min(len(lines), line_num + 1)
                    context_lines = lines[start_line:end_line]
                    context = '\n    '.join(context_lines)
                    references.append(f"{filename}:{line_num}\n    {context}")
        
        return references
    
    def suggest_id_fixes(self):
        """Provide suggestions for fixing ID issues"""
        suggestions = []
        issues = self.check_consistency()
        
        # Suggest fixes for duplicate IDs
        if issues['duplicate_ids']:
            suggestions.append("üîß Duplicate ID fixes:")
            for duplicate in issues['duplicate_ids']:
                suggestions.append(f"   - {duplicate}")
                # Extract ID from duplicate description
                if ':' in duplicate:
                    id_part = duplicate.split(':')[0]
                    # Suggest renumbering
                    if 'T2-CONTROL' in id_part:
                        next_available = self.find_next_available_id('T2-CONTROL')
                        suggestions.append(f"     üí° Consider renumbering to {next_available}")
                    elif 'T2-HAL' in id_part:
                        next_available = self.find_next_available_id('T2-HAL')
                        suggestions.append(f"     üí° Consider renumbering to {next_available}")
        
        # Suggest fixes for missing derivations
        if issues['missing_derivations']:
            suggestions.append("üìã Missing derivation fixes:")
            suggestions.append("   Add these fields to the following IDs:")
            for missing_id in issues['missing_derivations'][:5]:
                suggestions.append(f"   - {missing_id}: Add 'Derived From:', 'Decision Type:', 'Engineering Rationale:'")
        
        # Suggest fixes for broken cross-references
        if issues['broken_cross_refs']:
            suggestions.append("üîó Broken cross-reference fixes:")
            for broken_ref in issues['broken_cross_refs'][:3]:
                suggestions.append(f"   - {broken_ref}: Check filename or create missing file")
        
        return suggestions

class TraceabilityID:
    """Represents a traceability ID like T2-CONTROL-008"""
    
    def __init__(self, tier, category, number, full_id):
        self.tier = tier
        self.category = category
        self.number = number
        self.full_id = full_id
    
    def __str__(self):
        return self.full_id
    
    def __eq__(self, other):
        return self.full_id == other.full_id
    
    def __hash__(self):
        return hash(self.full_id)

if __name__ == '__main__':
    main()